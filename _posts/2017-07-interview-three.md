---
layout: post
category: interview-Three 2017
title: interview-Three 命令学习 
tags: interview-Three,2017
keywords: interview-Three,2017
---
<h2>面试三</h2>
<ul>

<li><p>
	Struts 2<br/>
同义词Struts2一般指Struts 2<br/>
Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。Struts 2是Struts的下一代产品，是在 struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。其全新的Struts 2的体系结构与Struts 1的体系结构差别巨大。Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。虽然从Struts 1到Struts 2有着太大的变化，但是相对于WebWork，Struts 2的变化很小。
</p></li>

<li><p>
	Struts 2<br/>
同义词Struts2一般指Struts 2<br/>
Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。Struts 2是Struts的下一代产品，是在 struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。其全新的Struts 2的体系结构与Struts 1的体系结构差别巨大。Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。虽然从Struts 1到Struts 2有着太大的变化，但是相对于WebWork，Struts 2的变化很小。
</p></li>

<li><p>
	Struts 2<br/>
同义词Struts2一般指Struts 2<br/>
Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。Struts 2是Struts的下一代产品，是在 struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。其全新的Struts 2的体系结构与Struts 1的体系结构差别巨大。Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。虽然从Struts 1到Struts 2有着太大的变化，但是相对于WebWork，Struts 2的变化很小。
</p></li>

<li><p>
	MyBatis<br/>
MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。
iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO） 
</p></li>

<li><p>
	 Apache Shiro<br/>
Apache Shiro（日语“堡垒（Castle）”的意思）是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理功能，可为任何应用提供安全保障 - 从命令行应用、移动应用到大型网络及企业应用。<br/>
Shiro为解决下列问题（我喜欢称它们为应用安全的四要素）提供了保护应用的API：<br/>
认证 - 用户身份识别，常被称为用户“登录”；<br/>
授权 - 访问控制；<br/>
密码加密 - 保护或隐藏数据防止被偷窥；<br/>
会话管理 - 每用户相关的时间敏感的状态。<br/>
Shiro还支持一些辅助特性，如Web应用安全、单元测试和多线程，它们的存在强化了上面提到的四个要素。
</p></li>

<li><p>
	jQueryEasyUI<br/>
jQuery EasyUI是一组基于jQuery的UI插件集合体，而jQuery EasyUI的目标就是帮助web开发者更轻松的打造出功能丰富并且美观的UI界面。开发者不需要编写复杂的javascript，也不需要对css样式有深入的了解，开发者需要了解的只有一些简单的html标签。

</p></li>

<li><p>
	java--Spring之AOP面向切片和Spring的简单用法<br/>

spring-aop的切片是基于spring框架的。<br/>
切片为什么要在Sping框架下呢？原因很简单：<br/>
① 切片中的方法是在实例对象执行方法的时候触发的，那么切片是和实例对象有关。<br/>
② 如果在代码执行过程中，对象是new出来的，那么这个new出来的实例对象怎么和切片类有关系呢？显然没有任何关系。那么要怎么样才能让切片类和实例对象有关呢？只有将实例对象放入一个容器中，要用的时候再取出来。这就是Spring框架要干的活了。所以切片方法要在spring框架下

Spring框架<br/>
spring框架简单点说就是：将对象Bean放入beanFactory中，在加载对应的配置xml的时候，就创建了实例化的bean，以后就是通过beanFactory.get方法去获取就是了。<br/>
如果XML上配置了<aop:config>，Aspect也注解了，那么切片中的方法就会运行两次，不报异常。

</p></li>

<li><p>
String、StringBuffer和StringBulder<br/>
String:<br/>
        String类是一个final类，创建的字符串对象具有不变性。在字符串创建时若不使用new关键字，会在常量池中先进行查找，若常量池中存在，则直接将其内存地址赋给<br/>

StringBuffer:<br/>
         StringBuffer类创建的字符串对象会在内存中分配一个缓冲区，当我们要对它构建的字符串对象添加字符时，会在缓冲区中进行字符的追加。若需要对字符串进行频繁的修改时，可以使用StringBuffer从而节省内存。另外，StringBuffer实现了线程同步，可在多线程模式下使用，具有多线程安全性。<br/>

StringBuilder:<br/>
          StringBuilder用法与StringBuffer相同，但是未能实现线程同步，不具有多线程安全性，故主要使用在单线程模式下！
</p></li>

<li><p>
	AOP面向切面<br/>
在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 
</p></li>

<li><p>
	Maven
Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。<br/>
Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven <br/>构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。<br/>
Maven这个单词来自于意第绪语（犹太语），意为知识的积累，最初在Jakata Turbine项目中用来简化构建过程。当时有一些项目（有各自Ant build文件），仅有细微的差别，而JAR文件都由CVS来维护。于是希望有一种标准化的方式构建项目，一个清晰的方式定义项目的组成，一个容易的方式发布项目的信息，以及一种简单的方式在多个项目中共享JARs。
</p></li>

<li><p>
	排序算法入之冒泡排序<br/>
标签： 冒泡排序<br/>
在开发中，对一组数据进行有序地排列是经常需要做的事情，所以掌握几种甚至更多的排序算法是绝对有必要的<br/>
本文章介绍的是排序算法中较简单的一种算法：冒泡排序<br/>
题外话：在深入学习更多排序算法后和在实际使用情况中，冒泡排序的使用还是极少的。它适合数据规模很小的时候，而且它的效率也比较低，但是作为入门的排序算法，还是值得学习的<br/>

先尝试用最简单的想法去实现排序，以此来比较学习冒泡排序<br/>
问题：设有一数组，其大小为10个元素（int   str[10]）数组内的数据是无序。现在要求我们通过编程将这个无序的数组变成一个从小到大排序的数组（从下标为0开始）
思路：按照题目的要求，毫无疑问，正确的结果应该就像这样： 1 2 3 4 5 6 7 8 9 10   要做到这样，最简单和最直接想到的方法就是进行对比交换。<br/>
首先，把10个数里最小的个数放到下标为0的位置上（str[0]）
通过将下标为0的数（str[0]）与剩下其余9个数进行对比交换（将较少者放置在下标为0的位置上），就可以得到这10个数最小的那个
10个数最小的那位确定后，接下来就要找剩下9个数最小的那个。<br/>
因为已经确定出一个最小的数，所以就不要动str[0]，直接从str[1]开始，与剩下的8个数对比交换，找出9个数中最小的那位放到下标为1（str[1]）的位置上
继续按照这个思路就可以将这十个数变成有序的（从小到大）的数组
</p></li>



</ui>


	<h3>springmvc的执行流程详解<h3>
<ui>
<li><p>
第一步：发起请求到前端控制器(DispatcherServlet)<br/>
第二步：前端控制器请求HandlerMapping查找 Handler<br/>
         可以根据xml配置、注解进行查找<br/>
第三步：处理器映射器HandlerMapping向前端控制器返回Handler<br/>
第四步：前端控制器调用处理器适配器去执行Handler<br/>
第五步：处理器适配器去执行Handler<br/>
第六步：Handler执行完成给适配器返回ModelAndView<br/>
第七步：处理器适配器向前端控制器返回ModelAndView<br/>
         ModelAndView是springmvc框架的一个底层对象，包括Model和view<br/>
第八步：前端控制器请求视图解析器去进行视图解析<br/>
         根据逻辑视图名解析成真正的视图(jsp)<br/>
第九步：视图解析器向前端控制器返回View<br/>
第十步：前端控制器进行视图渲染<br/>
         视图渲染将模型数据(在ModelAndView对象中)填充到request域<br/>
第十一步：前端控制器向用户响应结果<br/>
 
 
组件：<br/>
1、前端控制器DispatcherServlet（不需要程序员开发）<br/>
作用接收请求，响应结果，相当于转发器，中央处理器。<br/>
有了DispatcherServlet减少了其它组件之间的耦合度。<br/>
 
2、处理器映射器HandlerMapping(不需要程序员开发)<br/>
作用：根据请求的url查找Handler<br/>
 
 
3、处理器适配器HandlerAdapter<br/>
作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler<br/>
 
4、处理器Handler(需要程序员开发)<br/>
注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler<br/>
 
5、视图解析器View resolver(不需要程序员开发)<br/>
作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）<br/>
 
6、视图View(需要程序员开发jsp)<br/>
View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf...）
</p></li>
</ui>