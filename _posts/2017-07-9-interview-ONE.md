---
layout: post
category: interview-ONE 2017
title: interview-ONE 命令学习 
tags: interview-ONE,2017
keywords: interview-ONE,2017
---
<h2>集合一</h2>
 <ul>
 <li><p> 	
 jQuery<br/>
jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 
jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器 
 </p></li>

  <li><p>
 	jQuery UI<br/>
jQuery UI  是以 jQuery 为基础的开源 JavaScript 网页用户界面代码库。包含底层用户交互、动画、特效和可更换主题的可视控件。我们可以直接用它来构建具有很好交互性的web应用程序
 </p></li>

  <li><p>
 	jQueryEasyUI<br/>
jQuery EasyUI是一组基于jQuery的UI插件集合体，而jQuery EasyUI的目标就是帮助web开发者更轻松的打造出功能丰富并且美观的UI界面。开发者不需要编写复杂的javascript，也不需要对css样式有深入的了解，开发者需要了解的只有一些简单的html标签。
 </p></li>

  <li><p>
 	AJAX开发<br/>
AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。
AJAX = 异步 JavaScript和XML（标准通用标记语言的子集）。
AJAX 是一种用于创建快速动态网页的技术。
通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。
传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。
 </p></li>

  <li><p>
 	JSON<br/>
JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。
 </p></li>

  <li><p>
 	freemarker<br/>
FreeMarker是一款模板引擎： 即一种基于模板和要改变的数据，	并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具。	它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。
FreeMarker是免费的，基于Apache许可证2.0版本发布。其模板编写为FreeMarker Template Language（FTL），属于简单、专用的语言。需要准备数据在真实编程语言中来显示，比如数据库查询和业务运算，	之后模板显示已经准备好的数据。在模板中，主要用于如何展现数据，	而在模板之外注意于要展示什么数据。
 </p></li>

  <li><p>
 	servlet<br/>
Servlet（Server Applet），全称Java Servlet，暂无中文译文。是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。
Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。
最早支持Servlet标准的是JavaSoft的Java Web Server，此后，一些其它的基于Java的Web服务器开始支持标准的Servlet。
 </p></li>

   <li><p>
 	javaBean<br/>
JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，long和class方法获取。众所周知，属性名称符合这种模式，其他Java 类可以通过自省机制发现和操作这些JavaBean 的属性。
 </p></li>

   <li><p>
 	jxl.jar<br/>
本词条缺少名片图，补充相关内容使词条更完整，还能快速升级，赶紧来编辑吧！
jxl.jar是通过java操作excel表格的工具类库
 </p></li>

   <li><p>
 	ireport<br/>
iReport 是为JasperReports Library和JasperReports Server设计的报表可视化设计器。
iReport的遵循AGPL自由开源协议，在SourceForge.net开源社区发布[1]  。
根据iReport和Jasper Studio的维护公告，自iReport版本5.5.0之后，终止新功能的开发。在2015年12月31日以前，对iReport的维护仅限于严重缺陷的修复，不会再增加新的功能。
 </p></li>

   <li><p>
 	Itext<br/>
本词条缺少名片图，补充相关内容使词条更完整，还能快速升级，赶紧来编辑吧！
在企业的信息系统中，报表处理一直占比较重要的作用，本文将介绍一种生成PDF报表的Java组件--iText。通过在服务器端使用Jsp或JavaBean生成PDF报表，客户端采用超链接显示或下载得到生成的报表，这样就很好的解决了B/S系统的报表处理问题。
 </p></li>

   <li><p>
 	nginx<br/>
Nginx ("engine x") 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。
Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。
 </p></li>

   <li><p>
 	junit<br/>
JUnit是一个Java语言的单元测试框架。它由Kent Beck和Erich Gamma建立，逐渐成为源于Kent Beck的sUnit的xUnit家族中最为成功的一个。 JUnit有它自己的JUnit扩展生态圈。多数Java的开发环境都已经集成了JUnit作为单元测试的工具。[1-2] 
JUnit是由 Erich Gamma 和 Kent Beck 编写的一个回归测试框架（regression testing framework）。Junit测试是程序员测试，即所谓白盒测试，因为程序员知道被测试的软件如何（How）完成功能和完成什么样（What）的功能。Junit是一套框架，继承TestCase类，就可以用Junit进行自动测试了。
 </p></li>

    <li><p>
 	简单使用JDOM解析XML 完整版<br/>
使用JDOM解析XML<br/>
一、前言<br/>
JDOM是Breet Mclaughlin和Jason Hunter两大Java高手的创作成果，2000年初，JDOM作为一个开放源代码项目正式开始研发。JDOM是一种解析XML的Java工具包。 
DOM适合于当今流行的各种语言，包括Java,JavaScripte,VB,VBScript，Perl,C,C++等。它了为HTML和XML文档提供了一个可应用于不同平台的编程接口。W3C DOM的最新信息可从http://www.w3.org/TR2001/WD-DOM-Lever-3-Core-20010913查阅。微软在http://msdn.microsoft.com/library/default.asp?url=/library/en-us/xmlsdk30/htm/xmconxmldomuserguide.asp上也有DOM的详细技术信息。<br/>

DOM 的设计为了适用于不同的语言，它保留了不同语言中非常相似的API。但是它并不适合于Java编程者的习惯。而JDOM作为一种轻量级API被制定，它最 核心的要求是以Java为中心，只适合于Java语言，它遵循DOM的接口主要规则，除去了DOM中为了兼容各语言而与Java习惯的不同。<br/>

二、使用JDOM的前提条件<br/>
须要有SAX、DOM解析器的类文件，JDOM只是一种适合Java程序员来使用的Java XML解析器，目前流行的Java XML解析器还有：Apache Xerces Java、JAXP。
Xerces Java解析器是完全用Java编写的XML解析器，最新版本是2.5，它支持以下标准和API：<br/>

（1） XML1.0规范（第二版本）<br/>

（2） XML命名空间规范<br/>

（3） DOM2核心标准规范<br/>

（4） SAX2核心扩展<br/>

（5） JAXP1.2 ：是Sun提供的使用Java处理XML的接口API。<br/>

（6） XML Schema结构和数据类型标准 <br/>

还有最好的是它开放源代码，我们可以在http://xml.apache.org/dist/xerces-j/ 处去下载。下载文件Xerces-J-bin.2.5.0.zip<br/>
解压下载文件，得到四个压缩包加到项目的路径中（其实不要全加，但不熟的情况下考虑这么做）。<br/>
JDOM的二进制版本下载：http://www.jdom.org/downloads/index.html<br/>
把解压后的jdom.jar文件加到项目的类路径中，另外便于调试，还要下载它的源代码。
 </p></li>

    <li><p>
 	高性能的分布式内存对象缓存系统-Memcached简介<br/>
memcached虽然称为“分布式”缓存服务器，但服务器端并没有“分布式”功能。服务器端仅包括内存存储功能，其实现非常简单。至于memcached的分布式，则是完全由客户端程序库实现的。这种分布式是memcached的最大特点。 

Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态、数据库驱动网站的速度。Memcached基于一个存储键/值对的hashmap。其守护进程（daemon ）是用C写的，但是客户端可以用任何语言来编写，并通过memcached协议与守护进程通信。
 </p></li>

    <li><p>
 	j2ee<br/>
J2EE是一套全然不同于传统应用开发的技术架构，包含许多组件，主要可简化且规范应用系统的开发与部署，进而提高可移植性、安全与再用价值。
J2EE核心是一组技术规范与指南，其中所包含的各类组件、服务架构及技术层次，均有共同的标准及规格，让各种依循J2EE架构的不同平台之间，存在良好的兼容性，解决过去企业后端使用的信息产品彼此之间无法兼容，企业内部或外部难以互通的窘境。
J2EE组件和“标准的” Java类的不同点在于：它被装配在一个J2EE应用中，具有固定的格式并遵守J2EE规范，由J2EE服务器对其进行管理。J2EE规范是这样定义J2EE组件的：客户端应用程序和applet是运行在客户端的组件；Java Servlet和Java Server Pages (JSP) 是运行在服务器端的Web组件；Enterprise Java Bean (EJB )组件是运行在服务器端的业务组件。
 </p></li>

    <li><p>
 	SVN<br/>
SVN是Subversion的简称，是一个开放源代码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion。说得简单一点SVN就是用于多个人共同开发同一个项目，共用资源的目的
 </p></li>

    <li><p>
 	Maven<br/>
Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。
Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。
Maven这个单词来自于意第绪语（犹太语），意为知识的积累，最初在Jakata Turbine项目中用来简化构建过程。当时有一些项目（有各自Ant build文件），仅有细微的差别，而JAR文件都由CVS来维护。于是希望有一种标准化的方式构建项目，一个清晰的方式定义项目的组成，一个容易的方式发布项目的信息，以及一种简单的方式在多个项目中共享JARs。
 </p></li>

    <li><p>
 	tomcat<br/>
Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。
Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML（标准通用标记语言下的一个应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。
诀窍是，当配置正确时，Apache 为HTML页面服务，而Tomcat 实际上运行JSP 页面和Servlet。另外，Tomcat和IIS等Web服务器一样，具有处理HTML页面的功能，另外它还是一个Servlet和JSP容器，独立的Servlet容器是Tomcat的默认模式。不过，Tomcat处理静态HTML的能力不如Apache服务器。目前Tomcat最新版本为9.0。
 </p></li>

    <li><p>
 	web（互联网总称）<br/>
本词条由“科普中国”百科科学词条编写与应用工作项目 审核 。
web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在Internet上的一种网络服务，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网状结构。[1] 
 </p></li>

    <li><p>
 	mySQL（关系型数据库管理系统）<br/>
MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。
MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。
MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。
由于其社区版的性能卓越，搭配 PHP 和 Apache 可组成良好的开发环境
 </p></li>

    <li><p>
 	Oracle数据库<br/>
             MySQL是一种开放源代码的关系型数据库管理系统（RDBMS），MySQL数据库系统使用最常用的数据库管理语言--结构化查询语言（SQL）进行               数据库管理。 
Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。它是在数据库领域一直处于领先地位的产品。可以说Oracle数据库系统是目前世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小、微机环境。它是一种高效率、可靠性好的 适应高吞吐量的数据库解决方案。
 </p></li>
<li><p>
	线程与进程<br/>
进程是可并发执行的程序在某个数据集合上的一次计算活动，也是操作系统进行资源分配和调度的基本单位。<br/>
线程是操作系统进程中能够并发执行的实体，是处理器调度和分派的基本单位。<br/>
每个进程内可包含多个可并发执行的线程。 <br/>
线程自己基本不拥有系统资源，只拥有少量必不可少的资源：程序计数器、一组寄存器、栈。 <br/>
同属一个进程的线程共享进程所拥有的主存空间和资源。 <br/>
在传统OS中，拥有资源、独立调度和分派的基本单位都是进程，在引入线程的系统中，线程是调度和分派的基本单位，而进程是拥有资源的基本单位。<br/>
在同一个进程内线程切换不会产生进程切换，由一个进程内的线程切换到另一个进程内的线程时，将会引起进程切换。
</p></li>

<li><p>
	线程切换<br/>
上下文切换的开销 <br/>
当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为“上下文切换”(“context switch”)。CPU会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程。
</p></li>

<li><p>
	单线程与多线程<br/>
多线程可以提高程序的并行性，可以把任务分开有序执行，有效利用cpu资源，提高响应速度。但是并不代表它比单线程处理的速度快，在进行密集计算时，单线程的速度要比多线程快些。 <br/>
多线程的缺点： <br/>
1）增加资源消耗 <br/>
线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈。它也需要占用操作系统中一些资源来管理线程。 <br/>
多个线程在创建和切换时，消耗的时间和资源更多 <br/>
2）多个线程共享1个cpu，需要cpu不停地切换执行线程。
</p></li>

<li><p>
	java某些类为什么要实现Serializable接口？
当一个类实现了Serializable接口(该接口仅为标记接口,不包含任何方法定义),表示该类可以序列化.序列化的目的是将一个实现了Serializable接口的对象转换成一个字节序列,可以把该字节序列保存起来(例如:保存在一个文件里),以后可以随时将该字节序列恢复为原来的对象。 <br/>
序列化可以将内存中的类写入文件或数据库中。比如将某个类序列化后存为文件，下次读取时只需将文件中的数据反序列化就可以将原先的类还原到内存中。也可以将类序列化为流数据进行传输。总的来说就是将一个已经实例化的类转成文件存储，下次需要实例化的时候只要反序列化即可将类实例化到内存中并保留序列化时类中的所有变量和状态。 甚至可以将该字节序列放到其他计算机上或者通过网络传输到其他计算机上恢复，只要该计 算机平台存在相应的类就可以正常恢复为原来的对象。 <br/>
序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements <br/>Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。

</p></li>

<li><p>
	hashmap与hashtable的区别？以及如何使用，以及他的一些方法？<br/>
1、HashMap不是线程安全的 
hashmap是一个接口，是map接口的子接口，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。HashMap允许null key和null value，而hashtable不允许。 <br/>
2、HashTable是线程安全的一个Collection。 <br/>
HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 <br/>HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey。因为contains方法容易让人引起误解。 Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map接口的一个实现。 <br/>最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差别。 <br/>
总结： <br/>
hashmap线程不安全 允许有null的键和值 效率高一点、 方法不是Synchronize的，要提供外同步 有containsValue和containsKey方法 <br/>
hashtable 线程安全 不允许有null的键和值 效率稍低、 方法是Synchronize的 有contains方法方法 <br/>
Hashtable 继承于Dictionary 类 Hashtable 比HashMap 要旧 <br/>
HashMap 是Java1.2 引进的Map interface 的一个实现，HashMap是Hashtable的轻量级实现。<br/>

</p></li>

<li><p>
	利用hashmap对苹果的重量进行排序<br/>
一、按key值排序 <br/>
假设HashMap存储的键-值对为（String，Integer），按key排序可以调用JDK函数sort（默认的按字典升序）： <br/>
Set keySet = map.keySet(); <br/>
Collections.sort(keySet); <br/>
for(Iterator ite = keySet.iterator(); ite.hasNext();) { <br/>
String temp = ite.next(); <br/>
System.out.println(“key-value: “+temp+”,”+map.getValue(temp); <br/>
} <br/>
如果想要按字典的降序排列，则需改写sort方法里面的比较器Comparator： <br/>
Collections.sort(keySet, new Comparator() { <br/>
public int compare(Object o1, Object o2) { <br/>
if(Integer.parseInt(o1.toString())>Integer.parseInt(o2.toString()) <br/>
return 1; <br/>
if(Integer.parseInt(o1.toString())==Integer.parseInt(o2.toString()) <br/>
return 0; <br/>
else <br/>
return -1; <br/>
} <br/>
}); <br/>
二、按value值排序 <br/>
1)方法一：用两个list链表实现 <br/>
List keyList = new LinkedList(); <br/>
keyList.addAll(map.keySet()); <br/>
List valueList = new LinkedList(); <br/>
valueList.addAll(map.values()); <br/>
for(int i=0; i<br/>
</p></li>

<li><p>
	struts2拦截器<br/>
大部分时候，拦截器方法都是通过代理的方式来调用的。Struts 2的拦截器实现相对简单。当请求到达Struts 2的ServletDispatcher时，Struts 2会查找配置文件，并根据其配置实例化相对的拦截器对象，然后串成一个列表（list），最后一个一个地调用列表中的拦截器。事实上，我们之所以能够如此灵活地使用拦截器，完全归功于“动态代理”的使用。动态代理是代理对象根据客户的需求做出不同的处理。对于客户来说，只要知道一个代理对象就行了。那Struts2中，拦截器是如何通过动态代理被调用的呢？当Action请求到来的时候，会由系统的代理生成一个Action的代理对象，由这个代理对象调用Action的execute()或指定的方法，并在struts.xml中查找与该Action对应的拦截器。如果有对应的拦截器，就在Action的方法执行前（后）调用这些拦截器；如果没有对应的拦截器则执行Action的方法。其中系统对于拦截器的调用，是通过ActionInvocation来实现的。
</p></li>

<li><p>
	struts2接受参数的方式<br/>
1.用Action的属性： <br/>
在action 里面定义要接收的参数，并提供相应的setter,getter,和提交参数的名称一致，并不用做数据类型的转换。
相应提交方式可以用get 和post，如：testAction? name=admin <br/>
2.使用DomainModel： <br/>
在Action 里面不用很多的属性，而是用Model 层用到的模型，保存它的一个对象。相应提交方式可以用get 和post， 
如：testAction? resBananRc.name=admin <br/>
3.使用DTO–数据传输对象 <br/>
它的作用是接收参数，传递参数，并不是项目中的实体类。如用户注册时，会用到确认密码，所以要先把参数接收过 
来，做处理后，再传递给相应方法去创建User 对象。提交参数的方式的Domain Model 方式的相同。 <br/>
4.使用ModelDriven： <br/>
在创建Action 的时候，Action 实现了ModelDriven 接口，去调用接口的getModel()方法，取到了相关对象。 
相应提交方式可以用get 和post，如：testAction? name=admin <br/>
5.使用request对象： <br/>
此方法与与传统的JSP 等传接参数一样，即使用request. getParameter(“”)方法
</p></li>

<li><p>
	MYSQL查看运行状态<br/>
1、用命令行的show语句 <br/>
直接在命令行下登录Mysql，运行show status。 <br/>
2、用Mysql自带的mysqladmin工具查看status，使用以下命令：mysqladmin -uroot -p密码 status
</p></li>

<li><p>
	Servlet的doPost、doGet方法以及一些内置对象v
Serlvet接口只定义了一个服务方法就是service，而HttpServlet类实现了该方法并且要求调用下列的方法之一： <br/>
doGet：处理GET请求 <br/>
doPost：处理POST请求 <br/>
当发出客户端请求的时候，调用service 方法并传递一个请求和响应对象。Servlet首先判断该请求是GET 操作还是POST 操作。然后它调用下面的一个方法：doGet 或 doPost。如果请求是GET就调用doGet方法，如果请求是POST就调用doPost方法。doGet和doPost都接受请求(HttpServletRequest)和响应(HttpServletResponse)。 <br/>
doGet 是接收网页用get方法时调用的 <br/>
doPost 是用来接收post方法的 <br/>
get方法就像你在网页的地址栏里看到的一堆乱码,也就是url后面有参数 <br/>
post就是用表单传过去的,就好象把数据都打成包发过去一样 <br/>
1.request对象: <br/>
客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。 <br/>
2.response对象: <br/>
response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。 <br/>
3.session对象: <br/>
session对象指的是客户端与服务器的一次会话，从客户端连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例. <br/>
4.out对象: <br/>
out对象是JspWriter类的实例,是向客户端输出内容常用的对象 <br/>
5.page对象: <br/>
page对象就是指向当前JSP页面本身，有点像类中的this指针，它是java.lang.Object类的实例 <br/>
6.application对象: <br/>
application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。 <br/>
7.exception对象: <br/>
exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象 <br/>
8.pageContext对象: <br/>
pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的session，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本类名也叫pageContext。 <br/>
9.config对象: <br/>
config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）

</p></li>



 </ul>

